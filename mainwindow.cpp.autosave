/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** You may use this file under the terms of the BSD license as follows:
**
** "Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names
**     of its contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
** $QT_END_LICENSE$
**
****************************************************************************/
#include "glwidget.h"
#include "mainwindow.h"
#include "SampleShape.h"
#include "spineshape.h"
#include "meshshape.h"
#include "Canvas.h"
#include "Patch.h"

#include <QtWidgets>

MainWindow::MainWindow()
{
    centralWidget = new QWidget;
    setCentralWidget(centralWidget);

    glWidget = new GLWidget;

    glWidgetArea = new QScrollArea;
    glWidgetArea->setWidget(glWidget);
    glWidgetArea->setWidgetResizable(true);
    glWidgetArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    glWidgetArea->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    glWidgetArea->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored);
    glWidgetArea->setMinimumSize(50, 50);

    createActions();
    createMenus();

    initTools();

    QGridLayout *centralLayout = new QGridLayout;
    centralLayout->addWidget(glWidgetArea, 0, 0);

    centralWidget->setLayout(centralLayout);
    setWindowTitle(tr("Shady"));
    resize(1200, 900);
    initScene();
}

void MainWindow::initTools()
{

    QToolBar *toolbar = addToolBar("main toolbar");

    toolbar->addAction(newGridAct);
    toolbar->addAction(new2NGonAct);
    toolbar->addAction(newSpineAct);

    toolbar->addSeparator();

    toolbar->addAction(dragAct);

    toolbar->addSeparator();

    toolbar->addAction(extrudeEdgeAct);
    toolbar->addAction(extrudeFaceAct);
    toolbar->addAction(insertSegmentAct);
    toolbar->addAction(deleteFaceAct);

    toolbar->addSeparator();
}

void MainWindow::initScene(){
    //init scene
    Canvas::get()->initLights();
    Patch::setN(8);
}

void MainWindow::about()
{
    QMessageBox::about(this, tr("About Shady"), tr("<b>Shady</b> is an application in progress that implements theoretical framework developed atTexas A&M University for rendering 2D scenes as if they are part of 3D."));
}

void MainWindow::createActions()
{
    exitAct = new QAction(tr("E&xit"), this);
    exitAct->setShortcuts(QKeySequence::Quit);
    connect(exitAct, SIGNAL(triggered()), this, SLOT(close()));

    aboutAct = new QAction(tr("&About"), this);
    connect(aboutAct, SIGNAL(triggered()), this, SLOT(about()));

    dragAct = new QAction(tr("Drag"), this);
    dragAct->setShortcut(Qt::Key_Space);
    connect(dragAct, SIGNAL(triggered()), this, SLOT(flipDrag()));

    //view Act
    shadingOnAct = new QAction(tr("&Shading On"), this);
    shadingOnAct->setShortcut('S');
    shadingOnAct->setCheckable(true);
    connect(shadingOnAct, SIGNAL(triggered()), this, SLOT(toggleShading()));

    normalsOnAct = new QAction(tr("Show &Normals"), this);
    normalsOnAct->setShortcut('N');
    normalsOnAct->setCheckable(true);
    connect(normalsOnAct, SIGNAL(triggered()), this, SLOT(toggleNormals()));

    patchesOnAct = new QAction(tr("Show &Patches"), this);
    patchesOnAct->setShortcut('P');
    patchesOnAct->setCheckable(true);
    connect(patchesOnAct, SIGNAL(triggered()), this, SLOT(togglePathces()));

    //Mesh Shape Actions
    extrudeEdgeAct = new QAction(tr("&Extrude Edge"), this);
    extrudeEdgeAct->setShortcut(tr("Ctrl+E"));
    connect(extrudeEdgeAct, SIGNAL(triggered()), this, SLOT(selectExtrudeEdge()));

    extrudeFaceAct = new QAction(tr("Extrude &Face"), this);
    extrudeFaceAct->setShortcut(tr("Ctrl+F"));
    connect(extrudeFaceAct, SIGNAL(triggered()), this, SLOT(selectExtrudeFace()));

    insertSegmentAct = new QAction(tr("&Insert Segment"), this);
    insertSegmentAct->setShortcut(tr("Ctrl+I"));
    connect(insertSegmentAct, SIGNAL(triggered()), this, SLOT(selectInsertSegment()));

    deleteFaceAct = new QAction(tr("&Delete Face"), this);
    deleteFaceAct->setShortcut(tr("Ctrl+D"));
    connect(deleteFaceAct, SIGNAL(triggered()), this, SLOT(selectDeleteFace()));

    QActionGroup* toolset = new QActionGroup(this);

    dragAct->setCheckable(true);
    dragAct->setChecked(true);

    extrudeEdgeAct->setCheckable(true);
    extrudeFaceAct->setCheckable(true);
    insertSegmentAct->setCheckable(true);
    deleteFaceAct->setCheckable(true);

    extrudeEdgeAct->setActionGroup(toolset);
    extrudeFaceAct->setActionGroup(toolset);
    insertSegmentAct->setActionGroup(toolset);
    deleteFaceAct->setActionGroup(toolset);

    //new meshshapes
    newGridAct = new QAction(tr("Grid"), this);
    connect(newGridAct, SIGNAL(triggered()), this, SLOT(newGrid()));

    new2NGonAct = new QAction(tr("2NGon"), this);
    connect(new2NGonAct, SIGNAL(triggered()), this, SLOT(new2NGon()));

    newSpineAct = new QAction(tr("Spine"), this);
    connect(newSpineAct, SIGNAL(triggered()), this, SLOT(newSpine()));

    shapeLockAct = new QAction(tr("Lock"), this);
    connect(shapeLockAct, SIGNAL(triggered()), this, SLOT(newSpine()));

    shapeLockAct = new QAction(tr("Lock"), this);
    connect(shapeLockAct, SIGNAL(triggered()), this, SLOT(newSpine()));
}

void MainWindow::createMenus()
{
    fileMenu = menuBar()->addMenu(tr("&File"));   
    fileMenu->addAction("New");
    fileMenu->addAction("Open");
    fileMenu->addAction("Save");
    fileMenu->addAction("Save as");

    fileMenu->addAction("Import");
    fileMenu->addAction("Export");

    fileMenu->addSeparator();
    fileMenu->addAction(exitAct);

    viewMenu  = menuBar()->addMenu(tr("&View"));
    viewMenu->addAction(normalsOnAct);
    viewMenu->addAction(patchesOnAct);
    viewMenu->addAction(shadingOnAct);

    shapeMenu  = menuBar()->addMenu(tr("&Shape"));

    insertMenu =  shapeMenu->addMenu("Insert");
    shapeMenu->addAction("&Lock");

    shapeMenu->addAction("Arrange");
    shapeMenu->addAction("Group");
    shapeMenu->addAction("Parent");
    shapeMenu->addAction("Transform");
    shapeMenu->addAction("Rasterize");

    insertMenu->addAction(newGridAct);
    insertMenu->addAction(new2NGonAct);
    insertMenu->addAction(newSpineAct);

    toolsMenu  = menuBar()->addMenu(tr("Tools"));
    toolsMenu->addAction(extrudeEdgeAct);
    toolsMenu->addAction(extrudeFaceAct);
    toolsMenu->addAction(insertSegmentAct);
    toolsMenu->addAction(deleteFaceAct);

    selectMenu  = menuBar()->addMenu(tr("Select"));
    selectMenu->addAction("Select All");
    selectMenu->addAction("Select Inverse");
    selectMenu->addAction("Grow Selection");
    selectMenu->addAction("Clear Selection");

    renderMenu  = menuBar()->addMenu(tr("Render"));
    renderMenu->addAction("Render Options");
    renderMenu->addAction("Render");

    helpMenu    = menuBar()->addMenu(tr("&Help"));
    helpMenu->addAction(aboutAct);
}

QSize MainWindow::getSize()
{
    bool ok;
    QString text = QInputDialog::getText(this, tr("Grabber"),
                                         tr("Enter pixmap size:"),
                                         QLineEdit::Normal,
                                         tr("%1 x %2").arg(glWidget->width())
                                                      .arg(glWidget->height()),
                                         &ok);
    if (!ok)
        return QSize();

    QRegExp regExp(tr("([0-9]+) *x *([0-9]+)"));
    if (regExp.exactMatch(text)) {
        int width = regExp.cap(1).toInt();
        int height = regExp.cap(2).toInt();
        if (width > 0 && width < 2048 && height > 0 && height < 2048)
            return QSize(width, height);
    }

    return glWidget->size();
}

void MainWindow::keyPressEvent(QKeyEvent *event){

    bool ctrl = (event->modifiers() & Qt::ControlModifier);

    int key = event->key();

    if (key > 48 && key < 57 )
    {
        Canvas::MODE = (Canvas::EditMode_e)(key - 49);
    }

    switch(key){

        case Qt::Key_Delete :
             Canvas::get()->removeActive();
        break;

        case Qt::Key_N:
            {
                MeshShape* ms = new MeshShape();
                Canvas::get()->insert(ms);
                Canvas::get()->activate(ms);
            }
        break;

       case Qt::Key_PageUp:
            Canvas::get()->activeUp();
       break;

        case Qt::Key_PageDown:
             Canvas::get()->activeDown();
        break;

    }
    glWidget->updateGL();
}


void MainWindow::selectExtrudeEdge()
{
    MeshShape::setOPMODE(MeshShape::EXTRUDE_EDGE);
    unselectDrag();
}

void MainWindow::selectExtrudeFace()
{
    MeshShape::setOPMODE(MeshShape::EXTRUDE_FACE);
    unselectDrag();
}

void MainWindow::selectDeleteFace()
{
    MeshShape::setOPMODE(MeshShape::DELETE_FACE);
    unselectDrag();
}

void MainWindow::selectInsertSegment()
{
    MeshShape::setOPMODE(MeshShape::INSERT_SEGMENT);
    unselectDrag();
}

void MainWindow::flipDrag()
{
    Canvas::get()->flipMode();
    glWidget->updateGL();
}

void MainWindow::unselectDrag()
{
    Canvas::get()->isDragMode = false;
    dragAct->setChecked(false);
    glWidget->updateGL();
}

void MainWindow::toggleNormals(){
    Canvas::get()->isNormalsOn = normalsOnAct->isChecked();
    glWidget->updateGL();
}

void MainWindow::togglePathces(){
    Canvas::get()->isWireframeOn = patchesOnAct->isChecked();
    glWidget->updateGL();
}

void MainWindow::toggleShading(){
    Canvas::get()->isShadingOn = shadingOnAct->isChecked();
    glWidget->updateGL();
}

void MainWindow::new2NGon()
{
    MeshShape* pM = MeshShape::newMeshShape(Point(0,0), MeshShape::NGON);
    Canvas::get()->insert(pM);
    glWidget->updateGL();
}

void MainWindow::newGrid()
{
    MeshShape* pM = MeshShape::newMeshShape(Point(0,0), MeshShape::SQUARE);
    Canvas::get()->insert(pM);
    glWidget->updateGL();
}

void MainWindow::newSpine()
{
    //MeshShape* pM = MeshShape::newMeshShape(Point(0,0),MeshShape::SPINE);
    //Canvas::get()->insert(pM);
}

void MainWindow::toggleLockShape()
{
    
}

void MainWindow::transformShape()
{

}

void MainWindow ()
{

}
